Respostas da lista:

1))))))

A utilidade do conhecimento de ponteiros se dá devido a necessidade da alocação de memória em códigos um pouco mais avançados
onde tem-se por objetivo atividades ao qual exigem mais dos endereços ao qual o programa trabalha como troca, referenciação e etc. 
A importância é notória, pois com a utilização do ponteiro é possível evitar que alguns erros relacionados a conflitos de memória
ocorram em um programa (ao qual representam uma boa parte dos erros em códigos) e também na fluídez do código, ao qual sabe-se onde
os elementos estão alocados, sendo engenharia uma disciplina ao qual programação é essencial em alguns ramos, mostra-se a importância 
de compreender a sua aplicação. 



2))))))

trecho base:
//*
int i=3,j=5;
int *p, *q;
p = &i;
q = &j;
*//

p == &i; //  0x28ff44 

*p - *q;    // -2 

**&p;   //  3 

3 - *p/(*q) + 7;    // 10     (entretanto, se expecificar as casas decimais será 9,4.  



 
 
3)))))) Mostre o que será impresso por programa supondo que i ocupa o endereço 4094 na memória.

main(){
  int i=5, *p;
  p = &i;
  printf("%x %d %d %d %d", p,*p+2,**&p,3**p,**&p+4);
} 
RESPOSTA: 0x28ff44, 7, 5. 15 e 9 





4 )))))) Se i e j são variáveis inteiras e p e q ponteiros para int, quais das seguintes expressões de atribuição são ilegais?

a. p = &i;          CORRETA 
b. *q = &j; ERRADA
c. p = &*&i;        CORRETA
d. i = (*&)j; ERRADA
e. i = *&j;         CORRETA
f. i = &&j; ERRADA
g. q = *p; ERRADA
h. i = (*p)` + *q;  CORRETA





5)))))) Determine o que será mostrado pelo seguinte programa (compile-o, execute-o e verifique se foram obtidas as respostas esperadas).


NO CÓDIGO HAVIA UMA PARTE AO QUAL DEU ERRO, ONDE ENCONTRAVA-SE  ---  p5'; ---, AS ASPA SEGUINTE AO p5 GERAVA ERRO, LOGO EU OPTEI POR ALTERAR PARA
" p5++; " fazendo com que o valor final fosse distinto. 

SAÍDA:
20 
29.0 
P 
e 
P 
e 
t 
31 
45 
27 
31 
45 
27





6)))))))) 
(AS ÚNICAS MUDANÇAS NO CÓDIGO FORAM ESPAÇOS NA PARTE DO "printf()" PARA QUE A VISUALIZAÇÃO FOSSE MAIS FÁCIL.) 


SAÍDA:
contador/valor/valor/endereco/endereco
i = 0 vet[0] = 1.1 *(f + 0) = 1.1 &vet[0] = E830E430 (f + 0) = E830E430 
i = 1 vet[1] = 2.2 *(f + 1) = 2.2 &vet[1] = E830E434 (f + 1) = E830E434 
i = 2 vet[2] = 3.3 *(f + 2) = 3.3 &vet[2] = E830E438 (f + 2) = E830E438 
i = 3 vet[3] = 4.4 *(f + 3) = 4.4 &vet[3] = E830E43C (f + 3) = E830E43C 
i = 4 vet[4] = 5.5 *(f + 4) = 5.5 &vet[4] = E830E440 (f + 4) = E830E440 

A saída seguiu o esperado, se eu fosse pensar em mudar alguma coisa, seria talvez alterar "i=0" para "i=1", assim o array ficaria igual ao que foi 
entregue no código (vet[5]).






7))))))


#include <iostream>
using namespace std;

int main() {
int x[10];
int *px, i;
px = x;
for( i = 0; i < 10; i++){
  x[i] = i+1;
}
for( i = 0; i < 10; i++){
  cout << x[i] << ", ";
}
cout << "\n\n";

cout << &x    << "   " << px << "   " << *(px+0) << endl;
cout << &x[0] << "   " << px+1 << "   " << *(px+1)<< endl;
cout << &x[1] << "   " << px+2 << "   " << *(px+2)<<endl;
cout << &x[2] << "   " << px+3 << "   " << *(px+3) <<endl;
cout << &x[3] << "   " << px+4 << "   " << *(px+4)<<endl;
return 0;
}

SAÍDA: 
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 

0x7fffa1bc64c0   0x7fffa1bc64c0   1
0x7fffa1bc64c0   0x7fffa1bc64c4   2
0x7fffa1bc64c4   0x7fffa1bc64c8   3
0x7fffa1bc64c8   0x7fffa1bc64cc   4
0x7fffa1bc64cc   0x7fffa1bc64d0   5


COMO É POSSÍVEL PERCEBER, EM &x[2], ao qual é o terceiro elemento, ondereço é equivalente ao de px + 2, ao que quer dizer que há uma equivalencia entre ambos, logo

RESPOSTA: D) Pulo + 2;








8)))))))

int mat[4], *p, x;


 p = mat + 1;     VÁLIDA (ponteiro p recebe o array de mat+1, logo, indica que p recebe o endereço de mat +1 inteiro, logo, 4 bytes a frente
 p = mat;         VÁLIDA (ponteiro p recebe o primeiro elemento do array mat[4]
 p =`mat;         INVÁLIDA (a aspas fazem com que seja ilegível) 
 x = (*mat);      VÁLIDA (para ser sincero, copilou, mas eu não necessariamente entendi o valor resultado, mas sei que não destacou erros no programa) 
 
 
 
 
 
 
 9))))))))
 
 RESPOSTA: OS DOIS PROGRAMAS SÃO DIFERENTES POIS O PRIMEIRO IMPRIME OS ELEMENTOS NA SAÍDA, ENQUANTO O ÚLTIMO IMPRIME OS ENDEREÇOS DOS ELEMENTOS. 
 
 
 
 
 
 
 10))))))))
 
 A ))))) Se x for declarado como Char: teremos &x = 4092
 se (x+1) = 4093 ; se (x+2) = 4094; e se x+3 = 4095 
 
 B ))))) Se x[4] for declarado como int: teremos &x = 4092
 se (x+1) = 4094 ; se (x+2) = 4096; e se x+3 = 4098 
 
 C ))))) Se x[4] for declarado como float: teremos &x = 4092
 se (x+1) = 4096 ; se (x+2) = 4100; e se x+3 = 4104 
 
 D ))))) Se x[4] for declarado como double: teremos &x = 4092
 se (x+1) = 4100 ; se (x+2) = 4108; e se x+3 = 4116 
 
 
 CÓDIGO em C++: 
 
 #include <iostream>
using namespace std;

int main() {
char x[4];
char *x1;
x1 = x;
cout << "Endereço de char: "<< &x << "  " << &x[1] << " " << &x[2]<< endl;
int y[4];
int *x2;
x2 = y;
cout << "Endereço de int: "<< &y << endl;
float z[4];
float *x3;
x3 = z;
cout << "Endereço de float: "<< &z << endl;
double w[4];
double *x4;
x4 = w;
cout << "Endereço de double: "<< &w << endl;

cout << x1 << " " << (x1 + 1) << " " << (x1 + 2) << " " << (x1 + 3)<< endl; 
cout << x2 << " " << (x2 + 1) << " " << (x2 + 2) << " " << (x2 + 3)<< endl; 
cout << x3 << " " << (x3 + 1) << " " << (x3 + 2) << " " << (x3 + 3)<< endl; 
cout << x4 << " " << (x4 + 1) << " " << (x4 + 2) << " " << (x4 + 3)<< endl; 

return 0;
}


SAÍDA: 

Endereço de char: 0x7ffcbdeea858   
Endereço de int: 0x7ffcbdeea840
Endereço de float: 0x7ffcbdeea820
Endereço de double: 0x7ffcbdeea7f0
   
0x7ffcbdeea840 0x7ffcbdeea844 0x7ffcbdeea848 0x7ffcbdeea84c   // AUMENTA DE 4 EM 4 BYTES
0x7ffcbdeea820 0x7ffcbdeea824 0x7ffcbdeea828 0x7ffcbdeea82c   // AUMENTA DE 4 EM 4 BYTES 
0x7ffcbdeea7f0 0x7ffcbdeea7f8 0x7ffcbdeea800 0x7ffcbdeea808   // AUMENTA DE 8 EM 8 BYTES  
 

CÓDIGO EM C: 

#include <stdio.h>
#include <stdlib.h>

 int main(void){
  unsigned vet[4];
  char *y;
    y = vet;
  int *x;
    x = vet;
  float *z;
    z = vet;
  double *w;
    w = vet;
  printf("Endereço = %x %x %x %x\n", y, y+1, y+2, y+3);
  printf("Endereço = %x %x %x %x\n", x, x+1, x+2, x+3);
  printf("Endereço = %x %x %x %x\n", z, z+1, z+2, z+3);
  printf("Endereço = %x %x %x %x\n", w, w+1, w+2, w+3);
  return 0;
}

SAÍDA: 

Endereço = 52edf260 52edf261 52edf262 52edf263
Endereço = 52edf260 52edf264 52edf268 52edf26c
Endereço = 52edf260 52edf264 52edf268 52edf26c
Endereço = 52edf260 52edf268 52edf270 52edf278


NESSE CASO, ONDE DEFINIU-SE UM UNSIGNED ARRAY, FOI POSSÍVEL ASSOCIAR TODAS AS VARIÁVEIS AO MESMO E ACOMPANHAR A DIFERENÇA ENTRE O ENDEREÇOS 
E O 'CHAR' NÃO FOI OMITIDO, ONDE PERCEBE-SE QUE: 

Assim como na questão, o char aumenta de 1 em 1 bytes
Diferente da questão, o int aumenta de 4 em 4 bytes 
Assim como na questão, o float aumenta de 4 em 4 bytes 
Assim como na questão, o double aumenta de 8 em 8 bytes 

